/* eslint-disable no-param-reassign */
/* eslint-disable require-atomic-updates */
import { disconnectClient } from '~/client/api/disconnectClient';
import { getDeviceId } from '~/core/device';
import { proxyWebsocketEvents } from '~/core/events';
import { getNetworkTopic, subscribeTopic } from '~/core/subscription';
import { onUserDeleted } from '~/user/events/onUserDeleted';

import { getActiveClient } from './activeClient';
import { setActiveUser } from './activeUser';

import { getToken } from './getToken';
import { onClientBanned } from '../events';

/**
 * ```js
 * import { connectClient } from '@amityco/ts-sdk/client/api'
 * const success = await connectClient({
 *   userId: 'XYZ123456789',
 * })
 * ```
 *
 * Connects an {@link Amity.Client} instance to ASC servers
 *
 * @param params the connect parameters
 * @param params.userId the user ID for the current session
 * @param params.displayName the user's displayName for the current session
 * @param params.deviceId Manual override of the user's device id (for device management)
 * @param params.authToken The authentication token - necessary when network option is set to secure
 * @returns a success boolean if connected
 *
 * @category Client API
 * @async
 */
export const connectClient = async (
  params: Amity.ConnectClientParams,
  config?: Amity.ConnectClientConfig,
): Promise<boolean> => {
  const client = getActiveClient();
  client.log('client/api/connectClient', { apiKey: client.apiKey, ...params });

  // default values
  params.deviceId ??= getDeviceId();

  // @ts-ignore: in that particular case, typing can be
  // ignored since we enforce default values just before.
  const { accessToken, users } = await getToken(params);

  // manually setup the token for http transport
  client.http.defaults.headers.common.Authorization = `Bearer ${accessToken}`;

  // manually setup the token for ws transport
  client.ws.io.opts.query = { token: accessToken };

  // FIXME: events are duplicated if connectClient is called few times without disconnectClient
  // wire websocket events to our event emitter
  proxyWebsocketEvents(client.ws, client.emitter);

  // TODO: in phase 2, this should not be necessary. we should have WS
  // to be connected "on demand" rather than "by default"
  await new Promise(resolve => {
    client.ws.once('connect', resolve);
    client.ws.open();
  });

  client.userId = params.userId;
  client.accessToken = accessToken;

  setActiveUser(users[0]);

  if (config?.disableRTE !== true) {
    subscribeTopic(getNetworkTopic());
  }

  const subscriptions = [
    onClientBanned(() => {
      disconnectClient();
      subscriptions.forEach(fn => fn());
    }),
    onUserDeleted(() => null),
  ];

  return client.ws.connected;
};
