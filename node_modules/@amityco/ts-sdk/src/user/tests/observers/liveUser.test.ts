import { ASCApiError } from '~/core/errors';
import { disableCache, enableCache } from '~/cache/api';
import { LIVE_OBJECT_ENABLE_CACHE_MESSAGE } from '~/utils/constants';

import { liveUser } from '../../observers/liveUser';

import {
  pause,
  client,
  connectClient,
  disconnectClient,
  userQueryResponse,
  user11 as defaultUser,
} from '~/utils/tests';

const getSnapshot = () => {
  return {
    loading: true,
    error: undefined as any,
    data: undefined as undefined | Amity.User,
  };
};

describe('liveUser', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(async () => {
    enableCache();
  });

  afterEach(disableCache);

  test('it should show user if cache not enabled', () => {
    /*
     * NOTE: at the time of writing this test cache is diabled by default, but
     * there is a proposal to enable cache by default. So I'm disabling cache
     * here to ensure cache is disabled
     */
    disableCache();

    const callback = jest.fn();
    jest.spyOn(global.console, 'log');
    client.http.get = jest.fn();

    // call liveUser check if mocked console get's called with the correct
    // user
    client.use();
    liveUser(defaultUser.userId, callback);

    expect(console.log).toBeCalledWith(LIVE_OBJECT_ENABLE_CACHE_MESSAGE);
  });

  test('it should return user live object', async () => {
    const snapshot = getSnapshot();

    // mock response of queryUsers and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(userQueryResponse);

    liveUser(defaultUser.userId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    snapshot.loading = false;
    snapshot.data = defaultUser;

    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));
  });

  test('it should return error on api failure', async () => {
    const snapshot = getSnapshot();
    const error = new ASCApiError(
      'server error!',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    // mock response of queryUsers and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockRejectedValue(error);

    liveUser(defaultUser.userId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    snapshot.error = error;
    snapshot.loading = false;
    expect(callback).toHaveBeenLastCalledWith(expect.objectContaining(snapshot));
  });

  test('it should terminate updates on api failure', async () => {
    const snapshot = getSnapshot();
    const error = new ASCApiError(
      'server error!',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    // mock response of queryUsers and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockRejectedValue(error);

    liveUser(defaultUser.userId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    snapshot.error = error;
    snapshot.loading = false;
    expect(callback).toHaveBeenLastCalledWith(expect.objectContaining(snapshot));

    const updatedAt = new Date(defaultUser?.updatedAt ?? new Date());
    updatedAt.setDate(updatedAt.getDate() + 7);

    const updatedUser = {
      ...defaultUser,
      updatedAt: updatedAt.toISOString(),
    };
    client.emitter.emit('user.updated', { users: [updatedUser], files: [] });

    delete snapshot.error;
    snapshot.loading = false;
    snapshot.data = updatedUser;
    expect(callback).not.toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });

  test('it should not return updates on obtain once!', async () => {
    const snapshot = getSnapshot();

    // mock response of queryUsers and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(userQueryResponse);

    const unsub = liveUser(defaultUser.userId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    unsub();

    const updatedAt = new Date(defaultUser?.updatedAt ?? new Date());
    updatedAt.setDate(updatedAt.getDate() + 7);

    const updatedUser = {
      ...defaultUser,
      updatedAt: updatedAt.toISOString(),
    };
    client.emitter.emit('user.updated', { users: [updatedUser], files: [] });

    delete snapshot.error;
    snapshot.loading = false;
    snapshot.data = updatedUser;
    expect(callback).not.toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });

  const events: [string, keyof Amity.Events][] = [
    ['it should return updated user on onFetch', 'user.fetched'],
    ['it should return updated user on onUpdate', 'user.updated'],
    ['it should return updated user on onDelete', 'user.deleted'],
    ['it should return updated user on onFlagged', 'user.flagged'],
    ['it should return updated user on onUnflagged', 'user.unflagged'],
    ['it should return updated user on onFlagCleared', 'user.flagCleared'],
  ];

  test.each(events)('%s', async (test, event) => {
    const snapshot = getSnapshot();

    // mock response of queryUsers and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(userQueryResponse);

    liveUser(defaultUser.userId, callback);

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    const updatedAt = new Date(defaultUser?.updatedAt ?? new Date());
    updatedAt.setDate(updatedAt.getDate() + 7);

    const updatedUser = {
      ...defaultUser,
      updatedAt: updatedAt.toISOString(),
    };
    client.emitter.emit(event, { users: [updatedUser], files: [] });

    delete snapshot.error;
    snapshot.loading = false;
    snapshot.data = updatedUser;
    expect(callback).toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });
});
