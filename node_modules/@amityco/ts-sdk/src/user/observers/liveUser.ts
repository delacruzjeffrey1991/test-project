import { getActiveClient } from '~/client/api';
import { createQuery, runQuery } from '~/core/query';

import { LIVE_OBJECT_ENABLE_CACHE_MESSAGE } from '~/utils/constants';

import {
  onUserFetched,
  onUserDeleted,
  onUserUpdated,
  onUserFlagCleared,
  onUserFlagged,
  onUserUnflagged,
} from '../events';
import { getUser } from '../api';

/**
 * ```js
 * import { liveUser } from '@amityco/ts-sdk'
 *
 * let users = []
 * const unsub = liveUser(userId, response => merge(users, response.data))
 * ```
 *
 * Observe all mutation on a given {@link Amity.User}
 *
 * @param userId the ID of the user to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the users
 *
 * @category Message Live Object
 */
export const liveUser = (
  userId: Amity.User['userId'],
  callback: Amity.LiveObjectCallback<Amity.User>,
): Amity.Unsubscriber => {
  const { log, cache } = getActiveClient();
  let user: Amity.User;

  if (!cache) {
    console.log(LIVE_OBJECT_ENABLE_CACHE_MESSAGE);
  }

  const timestamp = Date.now();
  log(`liveUser(tmpid: ${timestamp}) > listen`);

  const disposers: Amity.Unsubscriber[] = [];

  const dispatcher = (data: Amity.LiveObject<Amity.User>) => {
    // we check updatedAt to see if the current snapshot is new so
    // we won't send old data back, only fresh new data
    if (user && data.data?.updatedAt === user?.updatedAt && data.origin !== 'server') return;

    callback(data);
    user = data.data;
  };

  const realtimeRouter = (user: Amity.User, action: Amity.UserActionType) => {
    dispatcher({ loading: false, data: user, origin: 'event' });
  };

  const onFetch = () => {
    const query = createQuery(getUser, userId, true);

    runQuery(query, ({ loading, data, error, origin }) => {
      dispatcher({ loading, data, origin, error });

      if (error) {
        // Terminate observe functionality on error
        disposers.forEach(fn => fn());
      }
    });
  };

  disposers.push(
    onUserFetched(user => realtimeRouter(user, 'onFetch')),
    onUserUpdated(user => realtimeRouter(user, 'onUpdate')),
    onUserDeleted(user => realtimeRouter(user, 'onDelete')),
    onUserFlagged(user => realtimeRouter(user, 'onFlagged')),
    onUserUnflagged(user => realtimeRouter(user, 'onUnflagged')),
    onUserFlagCleared(user => realtimeRouter(user, 'onFlagCleared')),
  );

  onFetch();

  return () => {
    log(`liveUser(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};
