import { disableCache, enableCache, pushToCache } from '~/cache/api';
import { getResolver } from '~/core/model';

import { liveChannels } from '../liveChannels';
import { prepareChannelPayload } from '../../utils/prepareChannelPayload';

import {
  client,
  pause,
  connectClient,
  disconnectClient,
  channel11,
  channelUser1,
  channelQueryResponse,
  channelQueryResponsePage2,
} from '~/utils/tests';

const getSnapshot = () => {
  return {
    data: [] as Amity.Channel[],
    loading: true,
    error: undefined as any,
  };
};

describe('liveChannels', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(enableCache);

  afterEach(disableCache);

  test('it should return channel collection', async () => {
    // mock response of queryChannels and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

    liveChannels({}, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    const snapshot = getSnapshot();

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    // cause we apply prepareChannelPayload on channel raw data from server
    const payload = prepareChannelPayload(channelQueryResponse.data);

    snapshot.data = payload.channels;
    snapshot.loading = false;

    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));
  });

  // table for channel filters
  const filters: [string, Amity.ChannelLiveCollection, number?][] = [
    ['deleted', { isDeleted: false }],
    ['tagged', { tags: ['tag2'] }],
    ['out excluded tags', { excludeTags: ['tag1'] }],
    ['member', { membership: 'member' }],
    ['not member', { membership: 'notMember' }, 1],
    ['all membership', { membership: 'all' }],
  ];

  test.each(filters)(
    'it should filter by %s channels',
    async (filter, params, expectedChannelIdx = 0) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

      const payload = prepareChannelPayload(channelQueryResponse.data);
      let snapshotData = [payload.channels[expectedChannelIdx]];

      // add channel users to cache for testing membership filter
      if (params.membership) {
        pushToCache(
          [
            'channelUsers',
            'get',
            getResolver('channelUsers')({
              channelId: channelQueryResponse.data.channels[0].channelId,
              userId: channelUser1.userId,
            }),
          ],
          channelUser1,
        );

        if (params.membership === 'all') {
          snapshotData = payload.channels;
        }
      }

      liveChannels(params, callback);

      expect(callback).toHaveBeenCalledTimes(1);

      const snapshot = getSnapshot();
      // check if cache data returned (should be empty)
      expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

      await pause();

      expect(callback).toHaveBeenCalledTimes(2);

      snapshot.loading = false;
      snapshot.data = snapshotData;

      expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));
    },
  );

  test('it should return method to fetch next page', async () => {
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue(channelQueryResponse)
      .mockResolvedValueOnce(channelQueryResponsePage2);

    liveChannels({}, callback);

    expect(callback).toHaveBeenCalled();

    await pause();

    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();

    await pause();

    // 4 -> becuase 1 local & server call each per call (2)
    expect(callback).toHaveBeenCalledTimes(4);

    const payload = prepareChannelPayload(channelQueryResponse.data);
    const payload2 = prepareChannelPayload(channelQueryResponsePage2.data);

    const snapshot = getSnapshot();
    snapshot.loading = false;
    snapshot.data = [...payload2.channels, ...payload.channels];

    expect(callback).toHaveBeenNthCalledWith(4, expect.objectContaining(snapshot));
  });

  const events: [string, keyof Amity.Events, Amity.Channel][] = [
    [
      'it should add new channel to collection onCreate',
      'v3.channel.didCreate',
      { ...channel11, channelId: 'new-channel-id' },
    ],
    ['it should edit channel in collection onUpdate', 'v3.channel.didUpdate', channel11],
    ['it should remove channel from collection onDelete', 'v3.channel.didDelete', channel11],
  ];

  test.each(events)('%s', async (test, event, channel) => {
    const snapshot = getSnapshot();

    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

    liveChannels({}, callback);

    await pause();
    expect(callback).toHaveBeenCalledTimes(2);

    client.emitter.emit(event, {
      channels: [channel],
      channelUsers: [channelUser1],
      users: [],
      files: [],
    });

    const payload = prepareChannelPayload(channelQueryResponse.data);
    const deletePayload = payload.channels.filter(
      channel => channel.channelId !== channel11.channelId,
    );

    snapshot.loading = false;
    // get data based on event
    switch (event) {
      case 'v3.channel.didCreate':
        snapshot.data = [channel, ...payload.channels];
        break;

      case 'v3.channel.didUpdate':
        snapshot.data = payload.channels;
        break;

      default:
        snapshot.data = deletePayload;
    }

    expect(callback).toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });
});
