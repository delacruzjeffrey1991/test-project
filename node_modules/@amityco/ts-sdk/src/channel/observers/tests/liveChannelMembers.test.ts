import { disableCache, enableCache } from '~/cache/api';
import {
  client,
  connectClient,
  disconnectClient,
  channelUser1,
  channelUser4,
  channelUserQueryResponse,
  channelUserQueryResponsePage3,
  channelUserQueryResponsePage2,
  channel11,
  pause,
} from '~/utils/tests';
import { liveChannelMembers } from '../liveChannelMembers';
import { prepareChannelPayload } from '../../utils';

const getSnapshot = () => {
  return {
    data: [] as Amity.Membership<'channel'>[],
    loading: true,
    error: undefined as any,
  };
};

describe('liveChannelMembers', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(enableCache);

  afterEach(disableCache);

  const { channelId } = channel11;

  test('it should return channel members collection', async () => {
    // mock response of queryChannels and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelUserQueryResponse);

    liveChannelMembers({ channelId }, callback);
    await pause();

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));

    const snapshot = getSnapshot();
    snapshot.data = channelUserQueryResponse.data.channelUsers;
    snapshot.loading = false;

    expect(callback).toHaveBeenNthCalledWith(2, expect.objectContaining(snapshot));
  });

  const filters: [string, Amity.ChannelMembersLiveCollection, Amity.Membership<'channel'>[]][] = [
    [
      'roles',
      { channelId, roles: channelUserQueryResponsePage3.data.channelUsers[0].roles },
      [channelUserQueryResponsePage3.data.channelUsers[0]],
    ],
    [
      'searched term',
      { channelId, search: 'use' },
      [channelUserQueryResponsePage3.data.channelUsers[0]],
    ],
    [
      'member',
      { channelId, memberships: ['member'] },
      [channelUserQueryResponsePage3.data.channelUsers[0]],
    ],
    [
      'muted members',
      { channelId, memberships: ['muted'] },
      [channelUserQueryResponsePage3.data.channelUsers[1]],
    ],
    [
      'banned members',
      { channelId, memberships: ['banned'] },
      [channelUserQueryResponsePage3.data.channelUsers[1]],
    ],
  ];

  test.each(filters)('it should filter channelUsers by %s', async (filter, params, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelUserQueryResponsePage3);

    liveChannelMembers(params, callback);
    await pause();

    const snapshot = getSnapshot();
    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(snapshot));

    snapshot.loading = false;
    snapshot.data = expected;

    expect(callback).toHaveBeenNthCalledWith(2, expect.objectContaining(snapshot));
  });

  test('it should return method to fetch next page', async () => {
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue(channelUserQueryResponse)
      .mockResolvedValueOnce(channelUserQueryResponsePage2);

    liveChannelMembers({ channelId }, callback);
    await pause();

    expect(callback).toHaveBeenCalled();
    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();
    await pause();

    const payload = prepareChannelPayload(channelUserQueryResponse.data);
    const payload2 = prepareChannelPayload(channelUserQueryResponsePage2.data);

    const snapshot = getSnapshot();
    snapshot.loading = false;
    snapshot.data = [...payload2.channelUsers, ...payload.channelUsers];

    expect(callback).toHaveBeenNthCalledWith(4, expect.objectContaining(snapshot));
  });

  const events: [string, keyof Amity.Events, Amity.Membership<'channel'>][] = [
    [
      'it should add new member to collection onMemberAdded',
      'v3.channel.didAddUsers',
      channelUser4,
    ],
    [
      'it should remove channel memeber from collection onMemberRemoved',
      'v3.channel.didRemoveUsers',
      channelUser1,
    ],
    [
      'it should update channel memeber membership on onChannelMemberBanned',
      'v3.channel.didBan',
      { ...channelUser1, membership: 'banned', isBanned: true },
    ],
    [
      'it should update channel memeber membership on onChannelMemberUnbanned',
      'v3.channel.didUnban',
      { ...channelUser1, membership: 'none', isBanned: false },
    ],
  ];

  test.each(events)('%s', async (test, event, channelUser) => {
    const snapshot = getSnapshot();

    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelUserQueryResponse);

    liveChannelMembers({ channelId }, callback);
    await pause();

    client.emitter.emit(event, {
      channels: [channel11],
      channelUsers: [channelUser],
      users: [],
      files: [],
    });

    const payload = prepareChannelPayload(channelUserQueryResponse.data);

    snapshot.loading = false;
    // get data based on event
    switch (event) {
      case 'v3.channel.didAddUsers':
        snapshot.data = [channelUser, ...payload.channelUsers];
        break;

      case 'v3.channel.didBan': {
        const bannedUserIdx = payload.channelUsers.findIndex(u => u.userId === channelUser.userId);
        payload.channelUsers[bannedUserIdx] = channelUser;

        snapshot.data = payload.channelUsers;
        break;
      }

      case 'v3.channel.didUnban': {
        const unbannedUserIdx = payload.channelUsers.findIndex(
          u => u.userId === channelUser.userId,
        );
        payload.channelUsers[unbannedUserIdx] = channelUser;

        snapshot.data = payload.channelUsers;
        break;
      }

      default:
        // delete payload
        snapshot.data = payload.channelUsers.filter(u => u.userId !== channelUser.userId);
    }

    expect(callback).toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });
});
