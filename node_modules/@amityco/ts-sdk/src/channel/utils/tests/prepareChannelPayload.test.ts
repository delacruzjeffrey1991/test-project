import {
  connectClient,
  disconnectClient,
  channel11,
  channel12,
  channelRaw1,
  channelRaw2,
  channelUser1,
  channelUser2,
} from '~/utils/tests';

import { prepareChannelPayload } from '../prepareChannelPayload';

beforeAll(async () => {
  await connectClient();
});

afterAll(async () => {
  await disconnectClient();
});

const responseSchema = {
  channels: [],
  channelUsers: [],
  files: [],
  users: [],
};

const tests = [
  {
    id: 1,
    desc: 'hasMention: false, unreadCount: 0, if channelUsers is empty',
    before: {
      ...responseSchema,
      channels: [channelRaw1],
    },
    after: {
      ...responseSchema,
      channels: [channel11],
    },
  },
  {
    id: 2,
    desc: 'hasMention: false, if channelUser.readToSegment >= channelUser.lastMentionedSegment',
    before: {
      ...responseSchema,
      channels: [channelRaw1],
      channelUsers: [channelUser1],
    },
    after: {
      ...responseSchema,
      channels: [channel11],
      channelUsers: [channelUser1],
    },
  },
  {
    id: 3,
    desc: 'unreadCount: 0, if channelUser.readToSegment = channel.messageCount',
    before: {
      ...responseSchema,
      channels: [channelRaw1],
      channelUsers: [channelUser1],
    },
    after: {
      ...responseSchema,
      channels: [channel11],
      channelUsers: [channelUser1],
    },
  },
  {
    id: 4,
    desc: 'hasMention: true, if channelUser.readToSegment < channelUser.lastMentionedSegment',
    before: {
      ...responseSchema,
      channels: [channelRaw2],
      channelUsers: [channelUser2],
    },
    after: {
      ...responseSchema,
      channels: [channel12],
      channelUsers: [channelUser2],
    },
  },
  {
    id: 5,
    desc: 'unreadCount: > 0, if channelUser.readToSegment < channel.messageCount',
    before: {
      ...responseSchema,
      channels: [channelRaw2],
      channelUsers: [channelUser2],
    },
    after: {
      ...responseSchema,
      channels: [channel12],
      channelUsers: [channelUser2],
    },
  },
  {
    id: 4,
    desc: 'hasMention: true, unreadCount: > 0, if 4 / 5 ',
    before: {
      ...responseSchema,
      channels: [channelRaw2],
      channelUsers: [channelUser2],
    },
    after: {
      ...responseSchema,
      channels: [channel12],
      channelUsers: [channelUser2],
    },
  },
];

describe('channel/utils/prepareChannelPayload', () => {
  tests.forEach(({ id, desc, before, after }) => {
    test(`${id} - ${desc}`, () => {
      expect(prepareChannelPayload(before)).toEqual(after);
    });
  });
});
