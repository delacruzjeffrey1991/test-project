/**
 * Manually computed type which links each key with a function
 * used to return the object's unique id. The type is computed
 * to avoid using any and give some typing security at the
 * resolver's level.
 */
type Resolvers<T extends Amity.Domain[] = Amity.Domain[]> = {
  [K in T[number]]: (model: Amity.Minimal[K]) => string;
};

/** @hidden */
const idResolvers: Resolvers = {
  user: ({ userId }) => userId,
  file: ({ fileId }) => fileId,
  role: ({ roleId }) => roleId,

  channel: ({ channelId }) => channelId,
  channelUsers: ({ channelId, userId }) => `${channelId}#${userId}`,
  message: ({ messageId }) => messageId,

  community: ({ communityId }) => communityId,
  category: ({ categoryId }) => categoryId,
  communityUsers: ({ communityId, userId }) => `${communityId}#${userId}`,
  post: ({ postId }) => postId,
  comment: ({ commentId }) => commentId,
  poll: ({ pollId }) => pollId,
  reaction: ({ reactionId }) => reactionId,

  stream: ({ streamId }) => streamId,

  follow: ({ from, to }) => `${from}#${to}`,
  followCount: ({ userId }) => userId,
};

/**
 * Retrieve the id resolver matching a domain name
 *
 * @param name the domain name for the resolve
 * @returns an idResolver function for the given domain name
 */
export const getResolver = <T extends Amity.Domain>(name: T) => idResolvers[name];
