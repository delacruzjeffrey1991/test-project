import { ASCApiError } from '~/core/errors';
import { getActiveClient } from '~/client/api';
import { createQuery, runQuery } from '~/core/query';
import {
  UNSYNCED_OBJECT_CACHED_AT_VALUE,
  LIVE_OBJECT_ENABLE_CACHE_MESSAGE,
  UNSYNCED_OBJECT_CACHED_AT_MESSAGE,
} from '~/utils/constants';

import { getMessage } from '../api';
import { onMessageUpdated, onMessageDeleted, onMessageFetched } from '../events';

/**
 * ```js
 * import { liveMessage } from '@amityco/ts-sdk'
 *
 * let messages = []
 * const unsub = liveMessage(messageId, response => merge(messages, response.data))
 * ```
 *
 * Observe all mutation on a given {@link Amity.Message}
 *
 * @param messageId the ID of the message to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Message Live Object
 */
export const liveMessage = (
  messageId: Amity.Message['messageId'],
  callback: Amity.LiveObjectCallback<Amity.Message>,
): Amity.Unsubscriber => {
  const { log, cache } = getActiveClient();
  let message: Amity.Message;
  let isUnsyncedObject = false;

  if (!cache) {
    console.log(LIVE_OBJECT_ENABLE_CACHE_MESSAGE);
  }

  const timestamp = Date.now();
  log(`liveMessage(tmpid: ${timestamp}) > listen`);

  const disposers: Amity.Unsubscriber[] = [];

  const dispatcher = (data: Amity.LiveObject<Amity.Message>) => {
    // we check updatedAt to see if the current snapshot is new so
    // we won't send old data back, only fresh new data
    if (message && data.data?.updatedAt === message?.updatedAt && data.origin !== 'server') return;

    callback(data);
    message = data.data;
  };

  const realtimeRouter = (message: Amity.Message, action: Amity.MessageActionType) => {
    dispatcher({ loading: false, data: message, origin: 'event' });
  };

  const onFetch = () => {
    const query = createQuery(getMessage, messageId, true);

    runQuery(query, ({ loading, data, error, origin, cachedAt }) => {
      if (cachedAt === UNSYNCED_OBJECT_CACHED_AT_VALUE) {
        dispatcher({
          data,
          origin,
          loading: false,
          error: new ASCApiError(
            UNSYNCED_OBJECT_CACHED_AT_MESSAGE,
            Amity.ClientError.DISALOOW_UNSYNCED_OBJECT,
            Amity.ErrorLevel.ERROR,
          ),
        });

        isUnsyncedObject = true;
        disposers.forEach(fn => fn());
      } else if (!isUnsyncedObject) {
        dispatcher({ loading, data, origin, error });
      }

      if (error) {
        // Terminate observe functionality on error
        disposers.forEach(fn => fn());
      }
    });
  };

  disposers.push(
    onMessageFetched(message => realtimeRouter(message, 'onFetch')),
    onMessageUpdated(message => realtimeRouter(message, 'onUpdate')),
    onMessageDeleted(message => realtimeRouter(message, 'onDelete')),
  );

  onFetch();

  return () => {
    log(`liveMessage(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};
