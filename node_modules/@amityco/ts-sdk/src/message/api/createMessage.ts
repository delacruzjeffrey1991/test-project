import { uuid } from '~/core/uuid';
import { fireEvent } from '~/core/events';
import { getActiveClient } from '~/client/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { UNSYNCED_OBJECT_CACHED_AT_VALUE } from '~/utils/constants';
import { upsertInCache, pullFromCache, pushToCache } from '~/cache/api';

/**
 * ```js
 * import { createMessage } from '@amityco/ts-sdk'
 * const created = await createMessage({
 *   channelId: 'foobar',
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Creates an {@link Amity.Message}
 *
 * @param bundle The data necessary to create a new {@link Amity.Message}
 * @returns The newly created {@link Amity.Message}
 *
 * @category Message API
 * @async
 */
export const createMessage = async <T extends Amity.MessageContentType>(
  bundle: Pick<
    Amity.Message<T>,
    'channelId' | 'parentId' | 'type' | 'tags' | 'metadata' | 'mentionees'
  > & {
    data?: Amity.Message<T>['data'];
    fileId?: Amity.Message<T>['fileId'];
  },
): Promise<Amity.Cached<Amity.Message>> => {
  const client = getActiveClient();

  client.log('user/createMessage', bundle);

  const { data } = await client.http.post<Amity.MessagePayload>('/api/v3/messages', bundle);

  const cachedAt = client.cache && Date.now();
  if (client.cache) ingestInCache(data, { cachedAt });

  const { messages } = data;

  fireEvent('v3.message.didCreate', { messages });

  return {
    data: messages[0],
    cachedAt,
  };
};

/**
 * ```js
 * import { createMessage } from '@amityco/ts-sdk'
 * const created = createMessage.locally({
 *   channelId: 'foobar',
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Creates an {@link Amity.Message} in cache
 *
 * @param bundle The data necessary to create a new {@link Amity.Message}
 * @returns The newly created {@link Amity.Message}
 *
 * @category Message API
 */
createMessage.optimistically = (
  bundle: Pick<
    Amity.Message,
    'channelId' | 'parentId' | 'type' | 'data' | 'tags' | 'metadata' | 'mentionees'
  >,
): Amity.Cached<Amity.Message> | undefined => {
  const client = getActiveClient();

  if (!client.cache) return;

  /*
   * when creating messages optimistically a messageId needs to be added by the
   * client, created a new variable so as to allow backward compatibility of API
   *
   * Updated to handle client requirement to add messageId while uploading
   * message with image. Temporary!
   */
  const bundleWithMessageId = { messageId: uuid(), ...bundle };

  // only log if cache is enabled
  client.log('user/createMessage.locally', bundleWithMessageId);

  const channel = pullFromCache<Amity.Channel>(['channel', 'get', bundleWithMessageId.channelId]);

  upsertInCache(['channel', 'get', bundleWithMessageId.channelId], {
    ...channel?.data,
    messageCount: (channel?.data.messageCount ?? 0) + 1,
  });

  // as reused to update created and updated time, which should be the same
  const createdTime = new Date().toISOString();

  const message = {
    userId: client.userId,
    channelSegment: (channel?.data.messageCount ?? 0) + 1,
    createdAt: createdTime,
    updatedAt: createdTime,
    ...bundleWithMessageId,
  } as Amity.Message;

  const cachedAt = UNSYNCED_OBJECT_CACHED_AT_VALUE;

  pushToCache(['message', 'get', message.messageId], message, { cachedAt });
  fireEvent('v3.message.didCreate', { messages: [message] });

  return {
    cachedAt,
    data: message,
  };
};
