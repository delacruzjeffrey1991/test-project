import { getActiveClient } from '~/client/api';

import { fireEvent } from '~/core/events';
import { toPage, toToken } from '~/core/query';
import { pullFromCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { getResolver } from '~/core/model';

/**
 * ```js
 * import { queryMessages } from '@amityco/ts-sdk'
 * const messages = await queryMessages({ channelId })
 * ```
 *
 * Queries a paginable list of {@link Amity.Message} objects
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Message} objects
 *
 * @category Message API
 * @async
 */
export const queryMessages = async (
  query: Amity.QueryMessages,
): Promise<Amity.Cached<Amity.Paged<Amity.Message>>> => {
  const client = getActiveClient();
  client.log('message/queryMessages', query);

  const { page = { limit: 10 }, ...params } = query;

  // API-FIX: parameters should be querystring. (1)
  // API-FIX: backend should answer Amity.Response (2)
  // API-FIX: pagination should not be indexed on channelSegment (3)
  // const { data } = await client.http.get<Amity.Response<Amity.Paged<Amity.MessagePayload>>>(
  const { data } = await client.http.get<Amity.MessagePayload & Amity.Pagination>(
    `/api/v3/messages`,
    {
      params: {
        ...params,
        options: {
          token: toToken(page, 'afterbefore'),
        },
      },
    },
  );

  // API-FIX: backend should answer Amity.Response (2)
  // const { paging, messages } = unwrapPayload(data)

  const { paging, ...payload } = data;
  const { messages } = payload;

  const cachedAt = client.cache && Date.now();

  if (client.cache) {
    ingestInCache(payload as Amity.MessagePayload, { cachedAt });

    const cacheKey = [
      'message',
      'query',
      { ...params, options: { ...page } } as Amity.Serializable,
    ];
    pushToCache(cacheKey, { messages: messages.map(getResolver('message')), paging });
  }

  fireEvent('v3.message.didFetch', { messages });

  const nextPage = toPage(paging.next);
  const prevPage = toPage(paging.previous);

  return { data: messages, cachedAt, prevPage, nextPage };
};

/**
 * ```js
 * import { queryMessages } from '@amityco/ts-sdk'
 * const messages = queryMessages.locally!({ channelId })
 * ```
 *
 * Queries a paginable list of {@link Amity.Message} objects from cache
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Message} objects
 *
 * @category Message API
 */
queryMessages.locally = (
  query: Parameters<typeof queryMessages>[0],
): Amity.Cached<Amity.Paged<Amity.Message>> | undefined => {
  const client = getActiveClient();
  client.log('message/queryMessages.locally', query);

  if (!client.cache) return;

  const { page = { limit: 10 }, ...params } = query;

  const queryKey = ['message', 'query', { ...params, options: { ...page } } as Amity.Serializable];
  const { data, cachedAt } =
    pullFromCache<{ messages: Pick<Amity.Message, 'messageId'>[] } & Amity.Pagination>(queryKey) ??
    {};

  if (!data?.messages.length) return;

  const messages: Amity.Message[] = data.messages
    .map(messageId => pullFromCache<Amity.Message>(['message', 'get', messageId])!)
    .filter(Boolean)
    .map(({ data }) => data);

  const prevPage = toPage(data?.paging.previous);
  const nextPage = toPage(data?.paging.next);

  return messages.length === data?.messages?.length
    ? { data: messages, cachedAt, prevPage, nextPage }
    : undefined;
};
