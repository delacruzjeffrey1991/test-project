import { disableCache, enableCache, pullFromCache, pushToCache } from '~/cache/api';
import { client, message11 } from '~/utils/tests';

import { queryMessages } from '../queryMessages';
import { onMessageFetched } from '../../events';

const messagesToQuery = [
  { ...message11, messageId: 'message11' },
  { ...message11, messageId: 'message12' },
];
const messageIds = ['message11', 'message12'];
const queryCriteriaWithoutPage = { channelId: messagesToQuery[0].channelId };
const pagingCriteria = { limit: 10 };
const queryCriteria = { ...queryCriteriaWithoutPage, page: pagingCriteria };
const pagingToken = {
  previous: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
  next: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
};

const getResolvedMessageValue = () => ({
  data: {
    messages: messagesToQuery,
    files: [],
    users: [],
    paging: pagingToken,
  },
});

describe('queryMessages', () => {
  test('should return fetched messages with correct paging', async () => {
    client.http.get = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    await expect(queryMessages(queryCriteria)).resolves.toEqual(
      expect.objectContaining({
        data: messagesToQuery,
        prevPage: { before: 55, limit: 10 },
        nextPage: { before: 55, limit: 10 },
      }),
    );
  });

  test('should update cache after fetching messages', async () => {
    enableCache();
    client.http.get = jest.fn().mockResolvedValue(getResolvedMessageValue());

    await queryMessages(queryCriteria);

    const recieved = pullFromCache([
      'message',
      'query',
      { ...queryCriteriaWithoutPage, options: pagingCriteria },
    ])?.data;

    expect(recieved).toEqual({
      messages: messageIds,
      paging: pagingToken,
    });

    disableCache();
  });

  test('should throw an error if request fails', async () => {
    client.http.get = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(queryMessages(queryCriteria)).rejects.toThrow('error');
  });

  test('should fire event `onMessageFetched`', async () => {
    let dispose;

    client.http.get = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageFetched(resolve);
    }).finally(dispose);

    await queryMessages(queryCriteria);
    await expect(callbackPromise).resolves.toEqual(messagesToQuery[0]);
  });
});

describe('queryMessages.locally', () => {
  beforeEach(() => enableCache());
  afterEach(() => disableCache());

  test('should return cached messages', () => {
    messagesToQuery.forEach(message => pushToCache(['message', 'get', message.messageId], message));

    pushToCache(['message', 'query', { ...queryCriteriaWithoutPage, options: pagingCriteria }], {
      messages: messageIds,
      paging: pagingToken,
    });

    expect(queryMessages.locally(queryCriteria)).toEqual(
      expect.objectContaining({
        data: messagesToQuery,
        prevPage: { before: 55, limit: 10 },
        nextPage: { before: 55, limit: 10 },
      }),
    );
  });

  test(`shouldn't return if individual message cache not exist`, () => {
    pushToCache(['message', 'query', { ...queryCriteriaWithoutPage, options: pagingCriteria }], {
      messages: messageIds,
      paging: pagingToken,
    });

    expect(queryMessages.locally(queryCriteria)).toBeUndefined();
  });

  test('it should return undefined if message not in cache', () => {
    expect(queryMessages.locally({ channelId: 'non-existent' })).toBeUndefined();
  });
});
