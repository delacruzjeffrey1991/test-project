import { UNSYNCED_OBJECT_CACHED_AT_VALUE } from '~/utils/constants';
import { disableCache, enableCache, pullFromCache, pushToCache } from '~/cache/api';

import { client, message11 } from '~/utils/tests';

import { onMessageCreated } from '../../events';
import { createMessage } from '../createMessage';

const messageToCreate = message11;
const { messageId, ...messageWithoutId } = message11;

const getResolvedMessageValue = () => ({
  data: {
    messages: [messageToCreate],
    users: [],
    files: [],
  },
});

describe('createMessage', () => {
  test('should return created message', async () => {
    client.http.post = jest.fn().mockResolvedValue(getResolvedMessageValue());

    const recieved = createMessage(messageWithoutId);

    await expect(recieved).resolves.toEqual(expect.objectContaining({ data: messageToCreate }));
  });

  test('should throw an error if request fails', async () => {
    client.http.post = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(createMessage(messageWithoutId)).rejects.toThrow('error');
  });

  test('should create cache after created messages', async () => {
    enableCache();
    client.http.post = jest.fn().mockResolvedValue(getResolvedMessageValue());

    const created = await createMessage(messageWithoutId);
    const recieved = pullFromCache(['message', 'get', created.data.messageId])?.data;

    expect(recieved).toEqual(expect.objectContaining(messageWithoutId));

    disableCache();
  });

  test('should fire event `onMessageCreated`', async () => {
    let dispose;
    client.http.post = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageCreated(resolve);
    }).finally(dispose);

    await createMessage(messageWithoutId);

    await expect(callbackPromise).resolves.toEqual(expect.objectContaining(messageWithoutId));
  });
});

describe('createMessage.optimistically', () => {
  beforeEach(() => enableCache());
  afterEach(() => disableCache());

  test('should create cache after created message', () => {
    const optimisticId = createMessage.optimistically(messageWithoutId)?.data?.messageId;
    const recieved = pullFromCache(['message', 'get', optimisticId])?.data;

    expect(recieved).toEqual(expect.objectContaining(messageWithoutId));
  });

  test('should increase message count after created message', () => {
    const { channelId } = messageWithoutId;
    pushToCache(['channel', 'get', channelId], { channelId, messageCount: 2 });

    createMessage.optimistically(messageWithoutId);
    const recieved = pullFromCache<Amity.Channel>(['channel', 'get', channelId])?.data;

    expect(recieved?.messageCount).toBe(3);
  });

  test('should fire event `onMessageCreated`', async () => {
    let dispose;

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageCreated(resolve);
    }).finally(dispose);

    createMessage.optimistically(messageWithoutId);

    await expect(callbackPromise).resolves.toEqual(expect.objectContaining(messageWithoutId));
  });

  test('should define object as unsynced object', async () => {
    expect(createMessage.optimistically(messageWithoutId)?.cachedAt).toEqual(
      UNSYNCED_OBJECT_CACHED_AT_VALUE,
    );
  });
});
