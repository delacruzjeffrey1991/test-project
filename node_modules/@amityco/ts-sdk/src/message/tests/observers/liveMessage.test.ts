import { ASCApiError } from '~/core/errors';
import { disableCache, enableCache } from '~/cache/api';
import {
  LIVE_OBJECT_ENABLE_CACHE_MESSAGE,
  UNSYNCED_OBJECT_CACHED_AT_MESSAGE,
} from '~/utils/constants';
import { liveMessage } from '../../observers/liveMessage';
import { createMessage } from '../../api';

import {
  pause,
  client,
  connectClient,
  disconnectClient,
  messageQueryResponse,
  message11 as defaultMessage,
} from '~/utils/tests';

const getSnapshot = () => {
  return {
    loading: true,
    error: undefined as any,
    data: undefined as undefined | Amity.Message,
  };
};

describe('liveMessage', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(async () => {
    enableCache();
  });

  afterEach(disableCache);

  test('it should show message if cache not enabled', () => {
    /*
     * NOTE: at the time of writing this test cache is diabled by default, but
     * there is a proposal to enable cache by default. So I'm disabling cache
     * here to ensure cache is disabled
     */
    disableCache();

    const callback = jest.fn();
    jest.spyOn(global.console, 'log');
    client.http.get = jest.fn();

    // call liveMessage check if mocked console get's called with the correct
    // message
    client.use();
    liveMessage(defaultMessage.messageId, callback);

    expect(console.log).toBeCalledWith(LIVE_OBJECT_ENABLE_CACHE_MESSAGE);
  });

  test('it should return message live object', async () => {
    const snapshot = getSnapshot();

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(messageQueryResponse);

    liveMessage(defaultMessage.messageId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    snapshot.loading = false;
    snapshot.data = defaultMessage;

    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));
  });

  test('it should return error on api failure', async () => {
    const snapshot = getSnapshot();
    const error = new ASCApiError(
      'server error!',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockRejectedValue(error);

    liveMessage(defaultMessage.messageId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    snapshot.error = error;
    snapshot.loading = false;
    expect(callback).toHaveBeenLastCalledWith(expect.objectContaining(snapshot));
  });

  test('it should terminate updates on api failure', async () => {
    const snapshot = getSnapshot();
    const error = new ASCApiError(
      'server error!',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockRejectedValue(error);

    liveMessage(defaultMessage.messageId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    snapshot.error = error;
    snapshot.loading = false;
    expect(callback).toHaveBeenLastCalledWith(expect.objectContaining(snapshot));

    const updatedAt = new Date(defaultMessage?.updatedAt ?? new Date());
    updatedAt.setDate(updatedAt.getDate() + 7);

    const updatedMessage = {
      ...defaultMessage,
      updatedAt: updatedAt.toISOString(),
    };
    client.emitter.emit('v3.message.didUpdate', { messages: [updatedMessage] });

    delete snapshot.error;
    snapshot.loading = false;
    snapshot.data = updatedMessage;
    expect(callback).not.toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });

  test('it should not return updates on obtain once!', async () => {
    const snapshot = getSnapshot();

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(messageQueryResponse);

    const unsub = liveMessage(defaultMessage.messageId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(snapshot));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    unsub();

    const updatedAt = new Date(defaultMessage?.updatedAt ?? new Date());
    updatedAt.setDate(updatedAt.getDate() + 7);

    const updatedMessage = {
      ...defaultMessage,
      updatedAt: updatedAt.toISOString(),
    };
    client.emitter.emit('v3.message.didUpdate', { messages: [updatedMessage] });

    delete snapshot.error;
    snapshot.loading = false;
    snapshot.data = updatedMessage;
    expect(callback).not.toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });

  const events: [string, keyof Amity.Events][] = [
    ['it should return updated message on onFetch', 'v3.message.didFetch'],
    ['it should return updated message on onUpdate', 'v3.message.didUpdate'],
    ['it should return updated message on onDelete', 'v3.message.didDelete'],
  ];

  test.each(events)('%s', async (test, event) => {
    const snapshot = getSnapshot();

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(messageQueryResponse);

    liveMessage(defaultMessage.messageId, callback);

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);

    const updatedAt = new Date(defaultMessage?.updatedAt ?? new Date());
    updatedAt.setDate(updatedAt.getDate() + 7);

    const updatedMessage = {
      ...defaultMessage,
      updatedAt: updatedAt.toISOString(),
    };
    client.emitter.emit(event, { messages: [updatedMessage] });

    delete snapshot.error;
    snapshot.loading = false;
    snapshot.data = updatedMessage;
    expect(callback).toHaveBeenNthCalledWith(3, expect.objectContaining(snapshot));
  });

  test('it should terminate updates for unsynced object', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn();
    const snapshot = getSnapshot();
    const data = { channelId: 'test', data: { text: 'text' } };

    const message = createMessage.optimistically(data);

    const error = new ASCApiError(
      UNSYNCED_OBJECT_CACHED_AT_MESSAGE,
      Amity.ClientError.DISALOOW_UNSYNCED_OBJECT,
      Amity.ErrorLevel.ERROR,
    );

    liveMessage(message!.data.messageId, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    snapshot.error = error;
    snapshot.loading = false;
    snapshot.data = message!.data;
    expect(callback).toHaveBeenLastCalledWith(expect.objectContaining(snapshot));
  });
});
