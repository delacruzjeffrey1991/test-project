import { ASCApiError } from '~/core/errors';
import { disableCache, enableCache } from '~/cache/api';
import { ENABLE_CACHE_MESSAGE } from '~/utils/constants';

import { queryMessages } from '../../api';
import { liveMessages } from '../../observers';

import {
  client,
  connectClient,
  disconnectClient,
  messages,
  message11 as defaultMessage,
} from '~/utils/tests';

describe('liveMessages', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(async () => {
    enableCache();
  });

  afterEach(disableCache);

  const { channelId } = messages;
  const returnValue = [{ messageId: messages.page1[0] }];
  const message = { ...defaultMessage, messageId: returnValue[0].messageId, channelId };

  test('it should show message if cache not enabled', () => {
    /*
     * NOTE: at the time of writing this test cache is diabled by default, but
     * there is a proposal to enable cache by default. So I'm disabling cache
     * here to ensure cache is disabled
     */
    disableCache();

    const callback = jest.fn();
    jest.spyOn(global.console, 'log');
    client.http.get = jest.fn();

    // call liveMessages check if mocked console get's called with the correct
    // message
    client.use();
    liveMessages({ channelId }, callback);

    expect(console.log).toBeCalledWith(ENABLE_CACHE_MESSAGE);
  });

  test('it should return message collection', async () => {
    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ channelId }, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: true,
      }),
    );

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();

    expect(callback).toHaveBeenCalledTimes(2);

    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: returnValue,
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should return error on api failure', async () => {
    const error = new ASCApiError(
      'server error!',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockRejectedValue(error);

    liveMessages({ channelId }, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: true,
      }),
    );

    await expect(queryMessages({ channelId })).rejects.toThrow();

    expect(callback).toHaveBeenCalledTimes(2);

    expect(callback).toHaveBeenLastCalledWith(
      expect.objectContaining({
        error,
        data: [],
        loading: false,
      }),
    );
  });

  test('it should filter deleted messages based on param', async () => {
    // mock response of queryMessages with a deleted message
    const returnValue = [
      { messageId: messages.page1[0], isDeleted: true },
      { messageId: messages.page1[1], isDeleted: false },
    ];

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ channelId, isDeleted: false }, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: true,
      }),
    );

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();

    expect(callback).toHaveBeenCalledTimes(2);

    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [returnValue[1]],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should return method to fetch next page', async () => {
    const returnValue2 = [{ messageId: messages.page2[0] }];

    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue({
        data: {
          messages: returnValue,
          paging: {
            previous: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
            next: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
          },
        },
      })
      .mockResolvedValueOnce({
        data: {
          messages: returnValue2,
          paging: {
            previous: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
            next: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
          },
        },
      });

    liveMessages({ channelId }, callback);

    expect(callback).toHaveBeenCalled();

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();

    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();

    // 4 -> becuase 1 local & server call each per call (2)
    expect(callback).toHaveBeenCalledTimes(4);

    expect(callback).toHaveBeenNthCalledWith(
      4,
      expect.objectContaining({
        data: [...returnValue2, ...returnValue],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onFetch', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ channelId }, callback);

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    client.emitter.emit('v3.message.didFetch', { messages: [message] });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [message],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onCreate', async () => {
    const newMessage = {
      ...message,
      messageId: 'new-messageId',
    };

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ channelId }, callback);

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    // fire new message creation event
    client.emitter.emit('v3.message.didCreate', { messages: [newMessage] });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [newMessage, ...returnValue],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onUpdate', async () => {
    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ channelId }, callback);

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    // fire new message creation event
    client.emitter.emit('v3.message.didUpdate', { messages: [message] });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [message],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onDelete', async () => {
    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ channelId }, callback);

    await expect(queryMessages({ channelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    // fire new message creation event
    client.emitter.emit('v3.message.didDelete', { messages: [message] });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: false,
      }),
    );
  });
});
